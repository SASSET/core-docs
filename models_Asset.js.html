<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>models/Asset.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-AccountLib.html">AccountLib</a><ul class='methods'><li data-type='method'><a href="module-AccountLib.html#.getAccount">getAccount</a></li><li data-type='method'><a href="module-AccountLib.html#.setAccount">setAccount</a></li></ul></li><li><a href="module-AssetModel.html">AssetModel</a><ul class='methods'><li data-type='method'><a href="module-AssetModel.html#.create">create</a></li><li data-type='method'><a href="module-AssetModel.html#.delete">delete</a></li><li data-type='method'><a href="module-AssetModel.html#.findAsset">findAsset</a></li><li data-type='method'><a href="module-AssetModel.html#.findAssets">findAssets</a></li><li data-type='method'><a href="module-AssetModel.html#.findByIdentifier">findByIdentifier</a></li><li data-type='method'><a href="module-AssetModel.html#.get">get</a></li><li data-type='method'><a href="module-AssetModel.html#.getPartitionsAssets">getPartitionsAssets</a></li><li data-type='method'><a href="module-AssetModel.html#.setIdentifiers">setIdentifiers</a></li><li data-type='method'><a href="module-AssetModel.html#createRevisionHistory">createRevisionHistory</a></li><li data-type='method'><a href="module-AssetModel.html#delete">delete</a></li><li data-type='method'><a href="module-AssetModel.html#lastRevision">lastRevision</a></li><li data-type='method'><a href="module-AssetModel.html#~delete">delete</a></li><li data-type='method'><a href="module-AssetModel.html#~set">set</a></li><li data-type='method'><a href="module-AssetModel.html#~value">value</a></li></ul></li><li><a href="module-PartitionModel.html">PartitionModel</a></li></ul><h3>Namespaces</h3><ul><li><a href="Gizmo.html">Gizmo</a><ul class='methods'><li data-type='method'><a href="Gizmo.html#.stripCommonRoot">stripCommonRoot</a></li><li data-type='method'><a href="Gizmo.html#.summarizePaths">summarizePaths</a></li><li data-type='method'><a href="Gizmo.html#.valueTypes">valueTypes</a></li></ul></li><li><a href="mongoose-helper.html">mongoose-helper</a><ul class='methods'><li data-type='method'><a href="mongoose-helper.html#.file2model">file2model</a></li><li data-type='method'><a href="mongoose-helper.html#.getCallerModelName">getCallerModelName</a></li><li data-type='method'><a href="mongoose-helper.html#.getFileStack">getFileStack</a></li><li data-type='method'><a href="mongoose-helper.html#.getLastCb">getLastCb</a></li><li data-type='method'><a href="mongoose-helper.html#.getObjectId">getObjectId</a></li><li data-type='method'><a href="mongoose-helper.html#.getObjectIds">getObjectIds</a></li><li data-type='method'><a href="mongoose-helper.html#.isObjectId">isObjectId</a></li><li data-type='method'><a href="mongoose-helper.html#.isPopulated">isPopulated</a></li><li data-type='method'><a href="mongoose-helper.html#.typeof">typeof</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">models/Asset.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Asset Mongoose Model - Used to create/edit/delete any Asset documents, as well as MDB documents in the Field, 
 * Partition and Revision collections that may be associated to the the Asset(s)
 * 
 * @module AssetModel
 * @see {@link http://mongoosejs.com/|Mongoose NodeJS Module}
 * @see {@link http://mongoosejs.com/docs/documents.html|Mongoose Documents}
 * @see {@link http://mongoosejs.com/docs/middleware.html|Mongoose Middleware}
 * @see {@link http://mongoosejs.com/docs/guide.html|Mongoose Schema}
 * @see {@link http://mongoosejs.com/docs/schematypes.html|Mongoose Schema Types}
 * @see {@link http://bluebirdjs.com/docs/api-reference.html|Bluebird Promise API}
 */
'use strict'

const _             = require( 'moar-lodash' )
const Promise       = require( 'bluebird' )
const Async         = require( 'async' )
const Util          = require( 'util' )
const AppRoot       = require( 'app-root-path' )
const Path          = require( 'path' )
const Columnify     = require( 'columnify' )

const _m            = AppRoot.require( './lib/helpers/mongoose-helper' )
const ModelName     = _m.file2Model( __filename )
const Log           = AppRoot.require( './lib/utils/logger' )({ model: `${ModelName}` })
const AccountLib    = AppRoot.require( './lib/account' )

Log.debug( `Model file loaded` )

/**
 * @name     AssetModel
 * @param    {Mongoose}                  Mongoose            Mongoose instance
 * @param    {module:AssetModel~Schema}  Mongoose.Schema     Schema thingy
 * @param    {module:AssetModel~Types}   Mongoose.Types      Mongoose document attribute types
 * @returns  {Mongoose.model}                                Asset Mongoose model
 */
const AssetModel = module.exports = Mongoose => {
    //const ModelException = Mongoose.exception
    const ModelException = Error

    //const _m2 = AppRoot.require('./lib/utils/mongodb-lodash')( Mongoose, _m )
    // Return this model, if it already exists
    if ( ! _.isUndefined( Mongoose.models[ ModelName ] ) ){
        return Mongoose.models[ ModelName ]
    }

    /** 
     * Reference to the Mongoose Schema object
     *
     * @typedef {Object} Schema
     * @name    module:AssetModel~Schema
     * @member  {Mongoose.Schema}
     * @see     {@link http://mongoosejs.com/docs/guide.html|Mongoose Schema}
     * @constant
     * @readonly
     */
    const Schema = Mongoose.Schema

    /** 
     * Reference to the Mongoose Types object
     *
     * @name Types
     * @member  {Mongoose.Types}
     * @see {@link http://mongoosejs.com/docs/schematypes.html|Mongoose Schema Types}
     * @constant
     * @readonly
     */
    const Types  = Mongoose.Types

    /**
     * The ObjectId of a Mongoose document. 
     *
     * @typedef {string} ObjectId
     * @name module:AssetModel~ObjectId
     * @see {@link http://mongoosejs.com/docs/api.html#schema-objectid-js|Mongoose ObjectId reference}
     * @see {@link https://docs.mongodb.com/manual/reference/method/ObjectId/| MongoDB ObjectId reference}
     * @example  Mongooses ObjectId type is an (lowercase)alpha/numeric string 24 character in length, 
     * for example: 507f191e810c19729de860ea
     */

    /**
     * AssetError exceptions
     *
     * @typedef     {Error} AssetException
     * @name        module:AssetModel~AssetException
     * @member      {Error}
     * @readonly
     * @property    {string}    name        Name of error encountered
     * @property    {number}    code        Code of error encountered
     * @property    {string}    message     Message of error
     * @property    {function}  toString    Returns the error name and message
     */

    /**
     * Asset Mongoose Schema
     *
     * @property    {string}                          status                Status of asset. This can be 'locked' (meaning 
     *                                                                      locked, but unsecured with no password), 'unlocked' 
     *                                                                      (meaning anyone with access can do anything), or 
     *                                                                      a 108 character password, which means the asset 
     *                                                                      is 'secured'
     * @property    {module:AssetModel~ObjectId}      _createdBy            Reference to a document in the Account collection 
     *                                                                      of the user who created the asset
     * @property    {module:AssetModel~ObjectId}      _updatedBy            Reference to a document in the Account collection 
     *                                                                      of whoever updated the asset last
     * @property    {module:AssetModel~Schema}        attrCache             This is a sub-schema with no format or property 
     *                                                                      restrictions, it via Asset/AttrCache middleware 
     *                                                                      plugin, which updates it via the documents 'save' 
     *                                                                      event) 
     * @property    {module:AssetModel~ObjectId[]}    attributes            Array of documents containing the assets attributes 
     *                                                                      and values
     * @property    {module:AssetModel~ObjectId}      attributes[]._field   Reference to the attributes field document
     * @property    {*}                               attributes[].value    Value of the attribute
     * @property    {module:PartitionModel~ObjectId}  _partition            Reference document to the parent partition (Assets 
     *                                                                      are associated to the partitions, not the other 
     *                                                                      way around)
     */
    const AssetSchema = new Schema({
        status: {
            type: Schema.Types.String,
            default: 'unlocked',
            select: true,
            minlength: 6,   // Length of 'locked'
            maxlength: 108, // Length of _.passwordHash value
            // Validate that its locked, unlocked, or a 108 character hash (made by _.passwordHash)
            validate: {
                validator: status => {
                    return _.includes( [ 'unlocked', 'locked' ], status ) || status.length === 108
                },
                message: '{VALUE} is not a valid status - Must be "locked", "unlocked" or a 108 character password hash'
            }
        },
        _createdBy: {
            //required: true,
            type: Schema.Types.ObjectId,
            ref: 'Account'
        },
        _updatedBy: {
            type: Schema.Types.ObjectId,
            ref: 'Account'
        },
        attrCache: new Schema({},{ strict: false }),
        attributes: [{
            _field: {
                type: Schema.Types.ObjectId,
                ref: 'Field',
                required: true
            },
            value: {
                type: Schema.Types.Mixed,
                required: true
            },
            // Determines if the value for this attribute on the asset doc is immutable or not
            immutable: {
                type: Schema.Types.Boolean,
                required: false,
                default: false
            }
        }],
        _partition: {
            type: Schema.Types.ObjectId,
            ref: 'Partition',
            required: true
        },
        // Determines if this asset can be modifiedd, or is immutable 
        immutable: {
            type: Schema.Types.Boolean,
            required: false,
            default: false
        }
    }, {
        /**
         * @type Date
         * @see http://mongoosejs.com/docs/guide.html#timestamps
         * @ignore
         */
        timestamps: {
            createdAt: 'createdAt',
            updatedAt: 'updatedAt'
        },
        strict: true
    })

    // PLUGINS/MIDDLEWARE PACKAGES-----------------------------------------

    // Load the below plugins via the bulk auto plugin loader
    AssetSchema.plugin( require('./middleware/PluginLoader') , {
        // Plugin to increment the documents revision number (__v)
        General    : 'DocVersionIncrement',
        // Load the plugin that will auto-populate the _createdBy and _updatedBy doc values
        Account    : 'UpdatedBy',
        // Plugin that will create revisions every time an asset is created/updated
        //Revision   : 'Init',
        // Plugin that will automatically update asset documents attrCache object with the attribute values
        //Asset      : 'AttrCache',
        //Asset       : [ 'AttrCache', 'History' ],
        // A plugin that turns the ugly E11000 (Unique index validation) error into a friendly error
        nocategory : 'mongoose-unique-validator'
    })

    // MIDDLEWARE ---------------------------------------------------------

    _.forEach( [ 'find', 'findOne', 'findOneById', 'findOneAndRemove', 'findOneAndUpdate' ], query => {
        AssetSchema.pre( query, function() {
            this
                .populate( 'attributes._field' )
                .populate( { path: '_partition' } )
        })
    })

    // VIRTUAL PROPERTIES -------------------------------------------------

    /**
     * Retrieve the primary value of an asset. The main goal of this is to quickly be able to reference
     * assets by their primary value, if one is set. This defaults back to the assets _id string
     *
     * NOTE: For the identifier virtual property to work properly, the _partition and _partition._fields
     *       both need to be populated, otherwise, the assets ID will be returned
     *
     * @this    module:AssetModel
     * @instance
     * @readonly
     * @name    module:AssetModel#identifier
     * @memberof module:AssetModel
     * @returns {string}    Whatever the value of the primary field is for this asset, or if there isn't a
     *                      primary field, or it isn't populated, return the assetID
     *
     * @example // In partition without a primary field, the identifier defaults to the documents ObjectID
     *  AssetModel.create( partitionId, ( error, assetDoc ) => {
     *      if ( error ) 
     *          return console.error( `Error: ${error}` )
     *
     *      console.log( `The asset ${assetDoc.identifier} was created successfully` ) 
     *      // => The asset 56d0819b655baf4a4a7f9cad was created successfully
     *  })
     * 
     * @example // In a partition with a primary field, the primaryField value is the identifier
     *  AssetModel.create( partitionId, {
     *      primaryAttribute: 'asset-123'
     *  }, ( error, assetDoc ) => {
     *      if ( error ) 
     *          return console.error( `Error: ${error}` )
     *
     *      console.log( `The asset ${assetDoc.identifier} was created successfully` ) 
     *      // => The asset asset-123 was created successfully
     *  })
     */
    AssetSchema.virtual('identifier').get(function () {
        // Value to return if no primary field is configured or no value is found
        const assetID = this._id

        // If the partition or partition fields werent loaded, then return null
        // (Should only happen if they weren't populated via the query)
        if ( ! this._partition || ! this._partition._fields ){
            return assetID
        }

        // Filter for the primary field..
        const primaryField = _.find( this._partition._fields, { primary: true } )

        // If no primary field is found, just return null
        if ( _.isUndefined( primaryField ) ){
            return assetID
        }

        // Filter through the assets attributes for the primary field attribute
        const primaryVal = _.find( this.attributes, f => {
            // If the field is an object, then the attributes._field has been populated,
            // so check the _id of the field, rather than the field itself..
            if ( _.isObject( f._field ) ){
                return f._field._id.toString() === primaryField._id.toString()
            }

            // Otherwise, just do a simple comparison
            return f._field.toString() === primaryField._id.toString()
        } )

        // If its not found, return null. This should only happen if the primary field was
        // set/configured after the asset was already made
        if ( ! primaryVal ){
            return assetID
        }

        // If the primary value is empty/null (which should only happen if the asset was
        // created before the primary field was configured), then return the assets ID
        return _.isEmpty( primaryVal.value )
            ? assetID
            : primaryVal.value
    })

    // INSTANCE METHODS ---------------------------------------------------

    /**
     * Dump asset attributes (into the console output)
     *
     * 
     */
    AssetSchema.methods.dumpAttrs = function ( ){
        var attrData = []
         
        _.forEach(this.attributes, ( attr, key ) => {
            attrData.push({
                attribute: attr._field.name,
                type: attr._field.type,
                value: ( _.isArray( attr.value ) ? attr.value.join( ', ' ) : attr.value )
            })
        })
        
        console.log(Columnify(attrData))
    }

    // --------------------------------------------------------------------

    /**
     * Delete an asset - This is meant to be more complicated than just removing the document from the collection, as
     * there should be certain other actions taken, and if it's a soft delete, just update the doc
     *
     * @function module:AssetModel#delete
     * @name     module:AssetModel#delete
     * @instance
     * @param   {?(string|module:AssetModel~deleteInstCb)=}  commentOrCb    Any comment to add for the logs, such as why 
     *                                                                      the asset was deleted
     * @param   {module:AssetModel~deleteInstCb=}            callback       Callback to fire when asset gets deleted 
     *                                                                      successfully (If undefined, then a Promise 
     *                                                                      will be returned from this method)
     * @returns {Promise}   Returns a Bluebird promise, but only if the callback param is undefined
     *
     * @example // Query for an asset, then delete it (with a comment)
     *  AssetModel.get( 'asset-123' )
     *      .then( assetDoc => { return assetDoc.delete( `Deleting asset ${assetDoc.identifier} (duplicate)`) })
     *      .then( data => console.log( 'Asset successfully deleted' ) )
     *      .catch( error => console.error( `Error: ${error}` ) )
     *
     * @example // Query for an asset, then delete it (without a comment)
     *  AssetModel.get( 'asset-123' )
     *      .then( assetDoc => assetDoc.delete )
     *      .then( data => console.log( 'Asset successfully deleted' ) )
     *      .catch( error => console.error( `Error: ${error}` ) )
     */
    AssetSchema.methods.delete = function ( comment ){
        return new Promise( ( res, rej ) => {

        }).asCallback( ( args  => _.findLast( args, a => _.isFunction( a ) ) )( arguments ) )
    }

    /**
     * Callback executed when an asset document is created.
     *
     * @function
     * @type function
     * @name deleteInstCb
     * @callback module:AssetModel~deleteInstCb
     * @param   {?(string|Exception)}   error           Error that was thrown, or null for no error
     * @param   {Object}                data            Uhm... not sure
     * @param   {string}                data.fooBar     Baz quux
     * @todo    Determine what the 'data' value for the callback should be
     *
     * @example // Query for an asset (providing callback function and no comment)
     *  AssetModel.get( 'asset-123', ( error, assetDoc ) => {
     *      if ( error ) 
     *          return console.error( `Error: ${error}` )
     *
     *      console.log( `Asset ${assetDoc.identifier} status: ${assetDoc.status}` )
     *      // => Asset asset-123 status: unlocked
     *  })
     */

    // --------------------------------------------------------------------

    /**
     * Create an entry in the Revisions collection with a copy of the assets current values
     *
     * @this        module:AssetModel
     * @function    module:AssetModel#createRevisionHistory
     * @name        module:AssetModel#createRevisionHistory
     * @param       {module:AssetModel~createRevisionCb=}    callback    Callback to fire (Optional, or promise returned)
     * @returns     {Promise}   Returns a Bluebird promise, but only if the callback param is undefined
     */
    AssetSchema.methods.createRevisionHistory = function( callback ) {
       return new Promise( ( res, rej ) => {

        }).asCallback( callback )
    }

    /**
     * Callback executed when the assets document revision history entry is created
     *
     * @function
     * @type function
     * @name createRevisionCb
     * @callback module:AssetModel~createRevisionCb
     * @param {?(string|Exception)}         error       Error that was thrown, or null for no error
     * @param {Object}                      data        Document containing any 
     * @param {module:AssetModel~ObjectId}  data._id    ID of the new revision entry
     */

    // --------------------------------------------------------------------

    /**
     * Retrieve an assets history
     *
     * @param   {string}    comment     Any comment to add for the logs, such as why the asset was deleted
     */
    AssetSchema.methods.history = function ( filterOrCallback ){
        return new Promise( ( res, rej ) => {
            
            if ( _.isPlainObject( filterOrCallback ) ){

            }
            else {

            }
                

        } ).asCallback( ( args  => _.findLast( args, a => _.isFunction( a ) ) )( arguments ) )
    }

    // --------------------------------------------------------------------

    /**
     * Get a specific revision number for the instances asset
     *
     * @param   {number}    revision    The assets revision number (NOT the revision ID)
     * @param   {function}  callback    Callback to execute if needed
     * @returns {Promise}   Promise, or callback executed if defined
     */
    AssetSchema.methods.getRevision = function( revision, callback ) {
        return Mongoose.models.Revision.getRevision({ assetId: this._id, revision: revision }, callback)
    }

    // --------------------------------------------------------------------

    /**
     * Lock an asset, or optionally change the assets locked password
     *
     * @param   {string|object|function}    pwdOrCb             Password to use to secure asset, if none, asset is
     *                                                          locked with no password; Or callback to be executed
     *                                                          (optional, which will lock password with no password)
     * @param   {function}                  callback            Callback to execute, or Promise returned
     * @var     {string}                    pwdOrCb.password    Password to use, if not set, then the asset will be
     *                                                          locked with no password
     * @var     {boolean}                   pwdOrCb.override    If an asset is already locked with a password, this will
     *                                                          override the unlock step by just resetting the password
     * @var     {string}                    pwdOrCb.current     Current password, used if the asset is currently secured,
     *                                                          and were re-locking it with a different password.
     *                                                          (Setting password.force to true will override this)
     * @returns {Promise}   Promise returned (with new asset doc if resolved), or callback is executed if defined
     */
    AssetSchema.methods.lock = function( pwdOrCb, callback ){
        return new Promise( ( res, rej ) => {
            // If the status isn't locked or unlocked, then assume its secured with a password hash
            if ( ! _.includes( [ 'locked','unlocked' ], this.status ) ){
                // If the asset is secured, and the first parameter is an object, then we can continue to check if it
                // can be unlocked
                if ( _.isObject( pwdOrCb )){
                    // If the override flag is true, then don't reject anything, otherwise, continue with the checks..
                    if ( pwdOrCb.override !== true ) {
                        // If were providing the current password of the secured asset, require a successful verification
                        if ( _.isString( pwdOrCb.current ) ) {
                            // Attempt to verify the provided password against the assets password (stored in the status)
                            if ( ! _.passwordVerify( pwdOrCb.current, this.status ) )
                                return rej( new Error( 'The password provided to unlock the asset does not match the current password used to secure the asset' ) )
                        }

                        // Otherwise, reject the promise, as the status requires the current password or an override
                        else {
                            return rej( new Error( 'The asset is currently secured, and the current password is needed to make any changes' ) )
                        }
                    }
                }

                // If the asset is secured, and pwdOrCb isn't an object (meaning there's no pwdOrCb.override or
                // pwdOrCb.current), then reject the promise
                else {
                    return rej( new Error( 'The asset is currently secured, and the current password is needed to make any changes' ) )
                }
            }

            // If this method has not yet been rejected, then we should be good to apply the changes to the asset

            // Set the password used to lock the asset, or leave it undefined
            const password = ( pwd => {
                if ( _.isString( pwd ) ){
                    return pwd
                }
                else if ( _.isObject( pwd ) &amp;&amp; _.isString( pwd.password ) ){
                    return pwd.password
                }
                
                return undefined
            })( pwdOrCb )

            // If the asset is locked (but unsecured), and there's no new password to secure the asset (meaning were
            // just locking it again, unsecured), then just resolve the method, don't re-save the asset document again,
            // that will just create a new revision with the same data
            if ( this.status === 'locked' &amp;&amp; _.isUndefined( this ) ){
                return res( this )
            }

            // If we've gotten this far, then the asset document will definitely be updated

            // Set the assets status
            this.status = ! _.isUndefined( password )
                ? _.passwordHash( password )
                : 'locked'

            // Make sure Mongoose knows to update it
            this.markModified( 'status' )

            // SAVE!..
            this.save( ( err, newAssetDoc ) => (
                ! _.isEmpty( err )
                    ? rej( _.setException( err ) )
                    : res( newAssetDoc )
            ))
        }).asCallback(( args  => _.findLast( args, a => _.isFunction( a ) ) )( arguments ) )
    }

    // --------------------------------------------------------------------

    /**
     * Lock an asset, or optionally change the assets locked password
     *
     * @param   {string|object|function}    pwdOrCb             Password to use to unlock asset (if its secured); Or an
     *                                                          object with the password and/or an override boolean; Or
     *                                                          callback to be executed (optional, which will lock
     *                                                          password with no password)
     * @param   {function}                  callback            Callback to execute, or Promise returned
     * @var     {string}                    pwdOrCb.password    Password to use, if not set, then the asset will be
     *                                                          locked with no password
     * @var     {boolean}                   pwdOrCb.override    If an asset is already locked with a password, this will
     *                                                          override the unlock step by just resetting the password
     * @returns {Promise}   Promise returned (with new asset doc if resolved), or callback is executed if defined
     */
    AssetSchema.methods.unlock = function( pwdOrCb, callback ){
        return new Promise( ( res, rej ) => {
            // If the asset is already unlocked, then just resolve the method, don't re-save the asset document again,
            // that will just create a new revision with the same data
            if ( this.status === 'unlocked' ){
                return res( this )
            }

            // If the status isn't 'locked', then assume its secured
            if ( this.status !== 'locked' ){
                // If the asset is secured, and the first parameter is an object, then we can continue to check if it
                // can be unlocked
                if ( _.isObject( pwdOrCb )){
                    // If the override flag is true, then don't reject anything, otherwise, continue with the checks..
                    if ( pwdOrCb.override !== true ) {
                        // If were providing the current password of the secured asset, require a successful verification
                        if ( _.isString( pwdOrCb.password ) ) {
                            // Attempt to verify the provided password against the assets password (stored in the status)
                            if ( ! _.passwordVerify( pwdOrCb.password, this.status ) )
                                return rej( new Error( 'The password provided to unlock the asset does not match the current password used to secure the asset' ) )
                        }

                        // Otherwise, reject the promise, as the status requires the current password or an override
                        else {
                            return rej( new Error( 'The asset is currently secured, and the current password is needed to make any changes' ) )
                        }
                    }
                }

                // If the first param is the password, then verify its the correct password
                else if ( _.isString( pwdOrCb ) ){
                    if ( ! _.passwordVerify( pwdOrCb, this.status ) )
                        return rej( new Error( 'The password provided to unlock the asset does not match the current password used to secure the asset' ) )
                }

                // If the asset is secured, and pwdOrCb isn't an object (meaning there's no pwdOrCb.override or
                // pwdOrCb.current), then reject the promise
                else {
                    return rej( new Error( 'The asset is currently secured, and the current password is needed to make any changes' ) )
                }
            }

            // If this method has not yet been rejected, then we should be good to apply the changes to the asset

            // Set the password used to lock the asset, or leave it undefined
            const password = ( pwd => {
                if ( _.isString( pwd ) ){
                    return pwd
                }
                else if ( _.isObject( pwd ) &amp;&amp; _.isString( pwd.password ) ){
                    return pwd.password
                }
                
                return undefined
            })( pwdOrCb )

            // If we've gotten this far, then the asset document will definitely be updated

            // Set the assets status
            this.status = 'unlocked'

            // Make sure Mongoose knows to update it
            this.markModified( 'status' )

            // SAVE!..
            this.save( ( err, newAssetDoc ) => (
                ! _.isEmpty( err )
                    ? rej( _.setException( err ) )
                    : res( newAssetDoc )
            ))

        }).asCallback(( args  => _.findLast( args, a => _.isFunction( a ) ) )( arguments ) )
    }

    // --------------------------------------------------------------------

    /**
     * Find revisions for associated asset
     *
     * @param   {object}        options             Options for filters
     * @param   {function}      callback            Callback to fire, (or promise returned)
     * @var     {Date}          options.date        Grab revisions created on specific date
     * @var     {Date}          options.before      Grab revisions created before date
     * @var     {Date}          options.after       Grab revisions created after date
     * @var     {object}        options.attributes  Attributes to filter for (Must be exact case)
     * @var     {Date}          options.except      Grab revisions not created on date
     * @var     {object}        options.where       Custom defined mongoose 'where' object content (merged with existing)
     * @var     {number}        options.limit       How many revisions to return
     * @var     {object|string} options.sort        Sort revisions by this
     * @return  {Promise}   Promise returned, or callback executed
     */
    AssetSchema.methods.revisions = function( options, callback ) {
        return new Promise( ( res, rej ) => {
            let where = { _asset: this._id }

            // Filter for any attributes (The MDB query needs to be setup like {'attrMeta.key': value} )
            if ( _.isObject( options.attributes ) )
                _.forEach( options.attributes, ( val, key ) => {
                    where[ `attrMeta.${key}` ] = val
                })

            // If any specific dates were defined...
            if ( _.isDate( options.after )
                || _.isDate( options.before )
                || _.isDate( options.date )
                || _.isDate( options.except ) ){
                where.createdAt = {}

                // Revisions created after date
                if ( _.isDate( options.after ) )
                    where.createdAt.$gt = options.after

                // Revisions created before date
                if ( _.isDate( options.before ) )
                    where.createdAt.$lt = options.before

                // revisions created on specific date
                if ( _.isDate( options.date ) ) {
                    // Create a window that will set a gte the date, and lte date + 24 hrs
                    where.createdAt.$gte = options.date
                    where.createdAt.$lte = new Date(new Date( options.date ).getTime() + 60 * 60 * 24 * 1000)
                }

                // Exclude revisions created on date
                if ( _.isDate( options.except ) )
                    where.createdAt.$ne = options.except
            }

            // If a specific where clause object was provided..
            if ( ! _.isObject( options.where ) )
                where = _.merge( where, options.where )

            const revisionQuery = Mongoose.models.Revision.find( where )

            // If a limit was specified
            if ( _.isNumber( options.limit ) )
                revisionQuery.limit( options.limit )

            // If sorting was requested..
            if ( _.isObject( options.sort ) || _.isObject( options.string ) )
                revisionQuery.sort( options.sort )

            // Execute the query..
            revisionQuery
                .then( data => {
                    if ( _.isEmpty( data ) ){
                        return rej( new Error( 'No revisions found' ) )
                    }

                    // Convert the array of objects into an object of objects, with the revision as the indexes
                    res( _.mapKeys( data, r => r.revision ) )
                })
                .catch( err => rej( _.setException( err ) ) )
        }).asCallback( callback )
    }

    // --------------------------------------------------------------------

    /**
     * Get the latest revision of an asset, that is NOT the current revision. This will search for all documents in the
     * revision table with the _asset ID of this asset, then sort it by the revision, and exclude the current
     * revision (__v value), then limit the responses to one document.
     *
     * @this        module:AssetModel
     * @function    module:AssetModel#lastRevisionCb
     * @name        module:AssetModel#lastRevision
     * @param       {?module:AssetModel~lastRevisionCb}  callback    Callback to execute, or promise returned if undefined
     * @returns     {Promise} 
     *
     * @example // Retrieve an asset document, query for the latest revision, then restore it (as a promise)
     *  AssetModel.getAsset( assetIdentifier )
     *      .then( assetDoc => assetDoc.lastRevision )
     *      .then( revisionDoc => revisionDoc.restore )
     *      .then( data => console.log( `Revision ID ${data.revision._id} restored to Asset ${data.asset._id}` ) )
     *      .catch( error => console.error( `Error: ${error}` ) )
     */
    AssetSchema.methods.lastRevision = function( callback ) {
        return new Promise( ( res, rej ) => {
            const Revision = Mongoose.models.Revision

            Revision.findOne( {
                _asset: this._id,
                // Get the latest revision that's NOT the current revision
                revision: { $ne: this.__v }
            } )
                .sort( { revision: 'desc' } ).limit( 1 )
                .then( data => {
                    if ( _.isEmpty( data ) ){
                        return rej( new Error( 'No revision found' ) )
                    }

                    res( data )
                } )
                .catch( err => rej( _.setException( err ) ) )
        }).asCallback( callback )
    }

    /**
     * Callback executed when an assets latest revision is queried
     *
     * @function
     * @type function
     * @name lastRevisionCb
     * @callback module:AssetModel~lastRevisionCb
     * @param {?(string|Exception)}         error               Error that was thrown, or null for no error
     * @param {?Object}                     revisionDoc         Document containing the last revision, or Null if none found
     * @param {module:AssetModel~ObjectId}  revisionDoc._id     ID of the revision document
     *
     * @example // Query for an asset, then query for the assets latest revision, and output the ObjectId
     *  AssetModel.getAsset( 'asset-1234', ( assetError, assetDoc ) => {
     *      if ( assetError )
     *          return console.error( `Error: ${assetError}` )
     *
     *      assetDoc.lastRevision( ( revisionError, revisionDoc ) => {
     *          if ( revisionError )
     *              return console.error( `Error: ${revisionError}` )
     *
     *          if ( ! revisionDoc )
     *              return console.log( `No previous revisions found for Asset ${assetDoc.identifier}` )
     *
     *          console.log( `The last revision ID for Asset ${assetDoc.identifier} is ${revisionDoc._id}` )
     *          // => The last revision ID for Asset asset-1234 is 46d0h19d655caf4a4a7f9xaa
     *      })
     *  })
     */

    // --------------------------------------------------------------------

    /**
     * Manage a specific attribute of a specific asset. The top attr instance method returns an object with three
     * functions that can be used to retrieve (attr.value) the attribute, update (attr.set) the attributes value, and
     * delete (attr.delete) the attribute.
     *
     * @param   {string}    name    Attributes name or the attributes ID (ObjectId)
     * @returns {object}    Object with 3 other functions
     * @note    Any attribute modifications (delete/set) only change the attribute in memory, meaning the asset document
     *          will still need to be saved via Doc.save() for the changes to take effect
     * @note    If there is somehow more than one attribute found with the name specified (which shouldn't happen unless
     *          someone interacts with documents directly), then only the first asset will be retrieved
     * @example const Hostname = assetDoc.attr('Hostname')
     *          console.log(`Asset Hostname: ${Hostname.value()}`)
     *          Hostname.set('something.whatever.tld')
     *          Hostname.delete()
     * @todo    This needs to execute AttrCache middleware
     */
    AssetSchema.methods.attr = function( name ) {
        if ( _.isUndefined( name ) ){
            return undefined
        }

        // Hold the asset in memory, since we a couple functions deep, lexical wont suffice
        const thisAsset = this

        // Shown before any errors thrown here
        const errPrefix = `Unable to retrieve/update the attribute ${name} for asset ID ${thisAsset._id}`

        // Make sure the attributes are set... This should never be false, but just in case
        if ( ! thisAsset.attributes || _.isUndefined( thisAsset.attributes[0] ) ){
            throw new Error( `${errPrefix} - No attributes were found .. How did that happen??` )
        }

        // Make sure the fields were populated (This is done via getAttributes() automatically)
        if ( ! _.isObject( thisAsset.attributes[0]._field ) ){
            throw new Error(`${errPrefix} - It doesn't look like the attributes._field was populated` )
        }

        // Get the index for the desired attribute from within the attributes array
        let attrIdx = _.findIndex( thisAsset.attributes, a => a._field.name.toLowerCase() === name.toLowerCase() || a._field._id.toString() === name )

        // If no attribute was found, then its undefined!
        if ( attrIdx === -1 ){
            return undefined
        }

        const foundAttrsTotal = _( thisAsset.attributes )
            .filter( a => a._field.name.toLowerCase() === name.toLowerCase() || a._field._id.toString() === name )
            .size()

        // Check if there is somehow more than 1 attribute with this name, this should never happen (unless someone tries
        // to do something manually). If more than 1 is found, just console a notice, saying we will only be impacting
        // the first one matched
        // @todo This should be logged, whenever logging is created
        if ( foundAttrsTotal > 1 ){
            Log.notice(`There were ${foundAttrsTotal} attributes found with the name ${name} (Not sure how `+
                            `that happened) - This method is attaching to only the first one found`)
        }

        /**
         * Attribute management functions. These are only accessible if the attribute itself has already been verified
         * via the above code, if it wasn't then either an error will be thrown, or undefined will be returned if the
         * attribute does not exist
         *
         * @var this.set    Set an attributes value (im memory, still needs to be saved via Doc.save())
         * @var this.delete Delete the specified attribute from memory
         * @var this.value  Retrieve the attributes value
         */
        return {
            /**
             * Set the attributes value in memory
             *
             * @param   {Mixed} value   New value of attribute
             * @returns {void}  Nothing to return..
             */
            set: value => {
                thisAsset.attributes[ attrIdx ].value = value
            },

            /**
             * Delete the attribute from the asset (in memory)
             *
             * @returns {boolean|object}    If there was an error removing it for some reason, then `false` is returned;
             *                              If the single attribute was deleted, return the attribute itself
             */
            delete: () => {
                // Use lodash to remove the attribute from the attributes, returning the deleted attribute
                const removed = _.remove( thisAsset.attributes, a => a._field.name.toLowerCase() === name.toLowerCase() || a._field._id.toString() === name )

                // If something was deleted.. mark the attributes as modified, or it wont get saved
                if ( ! _.isEmpty( removed ) ){
                    thisAsset.markModified('attributes')
                }

                // There shouldn't be more than 1 attribute with the same name... unless someone tries to do something manually
                if ( removed.length > 1 ){
                    Log.notice( `There was more than 1 attribute found for ${name}... weird` )
                }

                // Make sure there isn't an attribute with the same name, just to be sure it was deleted
                attrIdx = _.findIndex( thisAsset.attributes, a => a._field.name.toLowerCase() === name.toLowerCase() || a._field._id.toString() === name )

                // If somehow it wasn't deleted, then false
                if ( attrIdx !== -1 ){
                    return false
                }
                
                // If there was an attribute removed, then return it
                return removed[0]
            },

            /**
             * Retrieve attributes value
             *
             * @param   {boolean}   full    If true, then the entire attribute will be returned (should be populated)
             * @returns {Mixed|object}  If not full, attr value returned (mixed); If full, full attr returned (object)
             */
            value: full => {
                return full
                    ? thisAsset.attributes[ attrIdx ]
                    : thisAsset.attributes[ attrIdx ].value
            }
        }
    }

    // --------------------------------------------------------------------

    /**
     * Remove an attribute object from the assets attributes array using the attribute name or the field ID
     *
     * @param   {string}    name    Either the attribute name, or the field ID to delete
     * @returns {boolean|array|object}  true    - It never existed to delete
     *                                  false   - It wasn't successfully deleted
     *                                  object  - Deleted one attribute (deleted attribute data returned)
     *                                  array   - Deleted more than 1 attribute (deleted attributes data returned)
     *                                            This shouldn't ever happen, since attributes should only exist once
     *                                            per an asset, but via manual DB interaction or automation, mistakes
     *                                            can happen
     * @note    This just removes the attribute from the document in memory, the document still needs to be saved
     * db.revisions.find({ _asset: ObjectId('56ba258a98f0767514d0ee0b'), revision: 32 }).pretty()
     * @ignore
     */
    AssetSchema.methods.remove_LEGACY = function( name ) {
        if ( _.isUndefined( name ) ){
            throw new Error( 'No attribute name or field ID specified to delete' )
        }

        // Shown before any errors thrown here
        const errPrefix = `Unable to remove the attribute ${name} for asset ID ${this._id}`

        // Make sure the attributes are set... This should never be false, but just in case
        if ( ! this.attributes || _.isUndefined( this.attributes[0] ) ){
            throw new Error(`${errPrefix} - No attributes were found .. How did that happen??`)
        }

        // Make sure the fields were populated (This is done via getAttributes() automatically)
        if ( ! _.isObject( this.attributes[0]._field ) ){
            throw new Error(`${errPrefix} - It doesn't look like the attributes._field was populated`)
        }

        // Check if it exists..
        let attrIdx = _.findIndex( this.attributes, a => a._field.name.toLowerCase() === name.toLowerCase() || a._field._id.toString() === name )

        // If not, then don't try to delete it, but return true
        if ( attrIdx === -1 ){
            return true
        }

        // Use lodash to remove the attribute from the attributes, returning the deleted attribute
        const removed = _.remove( this.attributes, a => a._field.name.toLowerCase() === name.toLowerCase() || a._field._id.toString() === name )

        // If something was deleted.. mark the attributes as modified, or it wont get saved
        if ( ! _.isEmpty( removed ) ){
            this.markModified('attributes')
        }

        // There shouldn't be more than 1 attribute with the same name... unless someone tries to do something manually
        if ( removed.length > 1 ){
            Log.notice( `There was more than 1 attribute found for ${name}... weird` )
        }

        // Make sure there isn't an attribute with the same name, just to be sure it was deleted
        attrIdx = _.findIndex( this.attributes, a => a._field.name.toLowerCase() === name.toLowerCase() || a._field._id.toString() === name )

        // If somehow it wasn't deleted, then false
        if ( attrIdx !== -1 ){
            return false
        // If there was only one attribute removed (which should always be the case) return just that
        }
        else if ( removed.length === 1 ){
            return removed[0]
        }

        // If somehow there is more than 1 attr with the same name, (shouldn't happen!) return them all
        return removed
    }

    AssetSchema.methods.toString = function () {
        return this.identifier
    }

    // STATIC METHODS -----------------------------------------------------

    /**
     * Create one or multiple assets, associating them to the specified partition. This is much easier than inserting 
     * a new asset document manually, since the `attributes` parameter here can be a simple object, (or an array of 
     * objects for multiple assets), and the static/dynamic attributes are extracted by grabbing the partition fields 
     * and parsing the object
     *
     * @function    module:AssetModel.create
     * @alias       module:AssetModel.createAsset
     * @memberof    module:AssetModel
     * @this        module:AssetModel
     * @name        module:AssetModel.create
     * @throws      {module:AssetModel~AssetException}        This throws an AssetError exception
     * @param   {module:AssetModel~ObjectId}                    partitionId  The MDB ObjectId of the partition the assets 
     *                                                                       should be associated to
     * @param   {?(array|object|module:AssetModel~createCb)=}   attrsOrCb    An object of the attribute values (static and 
     *                                                                       dynamic attrs), or an array of objects (for 
     *                                                                       multiple assets), or undefined for empty 
     *                                                                       attribute values.
     * @param   {module:AssetModel~createCb=}                   callback     Callback to fire when the assets are successfully 
     *                                                                       or unsuccessfully created (If undefined, then a 
     *                                                                       Promise will be returned from this method)
     * @returns {Promise}   Returns a Bluebird promise, unless a callback is specified
     * @note    I HIGHLY recommend that the assets be created from the Partition instance methods, as they do most of
     *          the validation, this should only be used after the asset attributes are already validated
     * @todo    Validate the asset attributes against the partition field settings
     * @todo    Validate the partition ID exists (by getting the data)
     * @todo    Use above data to verify the primary attibute is populated
     * 
     * @example // Create a single asset without any attribute values defined
     *  AssetModel.create( PartitionsObjectId )
     *      .then( assetDoc => {
     *          console.log( `The asset ${assetDoc.identifier} was successfully created` ) 
     *          // => The asset 56a3e5c72b46691213a8f319 was successfully created
     *      })
     *      .catch( error => console.error( `Error: ${error}` ) )
     *
     * @example // Create a single asset in a partition with the primary field 'primaryAttr', using a callback
     *  AssetModel.create( PartitionsObjectId, {
     *      primaryAttr: 'asset-123', // Primary (string) attribute (Providing callback function)
     *      booleanAttr: false,       // Boolean attribute
     *      numericAttr: 123          // Numeric attribute
     *  })
     *      .then( assetDocs => {
     *          console.log( `The asset ${assetDoc.identifier} was successfully created` ) 
     *          // => The asset asset-123 was successfully created
     *      })
     *      .catch( error => console.error( `Error: ${error}` ) )
     * 
     * @example // Create two assets
     *  AssetModel.create( PartitionsObjectId, [{
     *      stringAttr: 'Asset #1', // String attribute
     *      booleanAttr: false,     // Boolean attribute
     *      numericAttr: 123        // Numeric attribute
     *  },{
     *      stringAttr: 'Asset #2', // String attribute
     *      booleanAttr: true,      // Boolean attribute
     *      numericAttr: 456        // Numeric attribute
     *  }])
     *      .then( assetDocs => {
     *          console.log( `The assets ${_.size( assetDocs )} were successfully created` ) 
     *          // => The assets _____ were successfully created
     *      })
     *      .catch( error => console.error( `Error: ${error}` ) )
     */
    AssetSchema.statics.create = 
    AssetSchema.statics.createAsset = function( partitionId, attrsOrCb, callback ) {
        /**
         * Internal command to create the document for a new asset
         *
         * @param   {(module:AssetModel~ObjectId|string)}           _pId        Partition ID to add asset to
         * @param   {?(Object|module:AssetModel~createStaticCb)=}   _attrsOrCb  Either the Assets attribute values (static 
         *                                                                      AND dynamic - The static and dynamic attributes 
         *                                                                      are separated, and the proper asset document 
         *                                                                      structure is constructed); Or a callback function
         * @param   {module:AssetModel~createStaticCb=}               _cb  Callback to fire when asset gets created 
         *                                                                      successfully (If undefined, then a Promise 
         *                                                                      will be returned from this method)
         */
        let _create = ( _pId, _attrsOrCb = {}, _cb ) => {
            console.log( `AssetModel.create > _create - _pId: ${_pId}; _attrsOrCb: ${Object.keys(_attrsOrCb)}` )

            return new Promise( ( res, rej ) => {
                // If the _attrsOrCb is defined as something other than an object or a function, abort
                if ( ! _attrsOrCb &amp;&amp; ! _.isObject( _attrsOrCb ) &amp;&amp; ! _.isFunction( _attrsOrCb ) ){
                    return rej( 'Asset attributes need to be in an object' )
                }

                // Default the attrs to an empty object (which may fail, if the partition has required fields)
                let attrs = ( _.isObject( _attrsOrCb ) ? _attrsOrCb : {} )

                // Values to pull out of the attributes object, as they aren't partition fields
                let statics = [ 'status' ]

                // Separate the static fields from the attributes object (Since they are stored differently in the DB)
                statics = _.removeObj( attrs, statics )

                // Since the asset attributes need to be inserted using the field IDs (as opposed to names), get those
                // first, then use the attribute names to filter for the needed key
                Mongoose.models.Partition.getFieldIdsByName( _pId, Object.keys( attrs ) )
                    .then( fields => {
                        // Construct the attribute values in the right format (Array of objects like:
                        // [ { _field: fieldId, value: 'Attr Val' } ]
                        let attrValues = _.map( attrs, ( value, key ) => ({ 
                            _field: fields[ key ], 
                            value 
                        }))

                        console.log('Fields:',fields)

                        // Create the new asset with several merged objects, should result in something like:
                        // { _partition: pId,
                        //   status: 'locked',
                        //   attributes: [ { _field: someFieldId, value: 'Some Value' } ] }
                        // @todo If this is broken, its probably because of me adding the 'return'
                        new this(
                            _.merge({ 
                                _partition: _pId 
                            }, statics, { 
                                attributes: attrValues 
                            })
                        ).save()
                            .then( assetDoc => {
                                console.log('assetDoc:',assetDoc)
                                Log.info( `Asset ID ${assetDoc._id.toString()} successfully created in Partition ID ${_pId}` )
                                return res( assetDoc )
                            } )
                            .catch( err => rej( err ) )
                    })
                    .catch( err => rej( _.setException( err ) ) )
            }).asCallback( ( args  => _.findLast( args, a => _.isFunction( a ) ) )( arguments ) )
        }

        return new Promise( ( res, rej ) => {

            // Validate the partition ID is a valid Mongoose ID
            if ( ! Types.ObjectId.isValid( partitionId.toString() ) ){
                return rej( 'Need a partition ID to add the assets to' )
            }

            // If the attributes are not unset AND not an object, then throw a hissy fit
            if ( ! attrsOrCb &amp;&amp; ! _.isObject( attrsOrCb ) &amp;&amp; ! _.isArray( attrsOrCb ) &amp;&amp; ! _.isFunction( attrsOrCb ) ){
                return rej( 'Asset attributes need to be in an object (If creating a single asset), or an array of ' 
                    + 'objects (when creating multiple), or not at all (to create an asset with empty attributes)' )
            }

            // If attrsOrCb is falsey, then just use an empty object (creating a partition with no attr values)
            //attrsOrCb = ( _.isObject( attrsOrCb ) ? attrsOrCb : {} )
            if ( ! attrsOrCb ){
                attrsOrCb = {}
            }

            // Check if an array is specified, which would mean were creating more than one asset
            if ( _.isArray( attrsOrCb ) ){
                // If so, then create the asset documents asynchronously
                Async.mapSeries( attrsOrCb, ( attrs, cb ) => {
                    // Create this asset, and send the new asset doc data via the cb
                    //_create( partitionId, attrs, ( err, assetDoc ) => {
                    //    cb( err, assetDoc )
                    //} )
                    _create( partitionId, attrs )
                        .then( assetDoc => {
                            console.log('Created:',assetDoc)
                            cb( null, assetDoc )
                        } )
                        .catch( err => {
                            console.log('Errored:', err)
                            cb( err )
                        })
                }, ( err, results ) => {
                    console.log('ERR:',err)
                    console.log('RESULTS:',results)
                    if ( err ){
                        console.log('Async Error:',err)
                        /*
                        return rej( new AppError({
                            code: 'partition.assets.create.createFailed',
                            data: err
                        }) )
                        */

                        return rej( `Error(s) encountered while creating the asset documents - ${err}` )
                    }
                    console.log('Async Result:',results)
                    return res( results )
                })
            }

            // Creating a single asset
            else {
                _create( partitionId, attrsOrCb )
                    .then( assetDoc => res( assetDoc ) )
                    .catch( err => rej( err ) )
            }
        }).asCallback( ( args  => _.findLast( args, a => _.isFunction( a ) ) )( arguments ) )
    }

    /**
     * Callback executed when a Asset document is created and added to the MDB collection
     *
     * @function
     * @type function
     * @name createCb
     * @callback module:AssetModel~createCb
     * @param {?(string|Exception)}         error               Error that was thrown, or null for no error
     * @param {Object}                      data                MDB document of the newly created Asset
     * @param {module:AssetModel~ObjectId}  data._partition     ID of partition document this asset is associated to
     *
     * @example // Create a single asset without any attribute values defined
     *  AssetModel.create( PartitionsObjectId, ( error, assetDoc ) => {
     *      if ( error ) 
     *          return console.error( `Error: ${error}` )
     *
     *      console.log( `The asset ${assetDoc.identifier} was successfully created` ) 
     *      // => The asset 56a3e5c72b46691213a8f319 was successfully created
     *  })
     * 
     * @example // Create a single asset in a partition with the primary field 'primaryAttr', using a callback
     *  AssetModel.create( PartitionsObjectId, {
     *      primaryAttr: 'asset-123',   // Primary (string) attribute (Providing callback function)
     *      booleanAttr: false,         // Boolean attribute
     *      numericAttr: 123            // Numeric attribute
     *  }, ( error, assetDoc ) => {
     *      if ( error ) 
     *          return console.error( `Error: ${error}` )
     *
     *      console.log( `The asset ${assetDoc.identifier} was successfully created` ) 
     *      // => The asset asset-123 was successfully created
     *  })
     *
     * @example // Create two assets
     *  AssetModel.create( PartitionsObjectId, [{
     *      stringAttr: 'Asset #1', // String attribute
     *      booleanAttr: false,     // Boolean attribute
     *      numericAttr: 123        // Numeric attribute
     *  },{
     *      stringAttr: 'Asset #2', // String attribute
     *      booleanAttr: true,      // Boolean attribute
     *      numericAttr: 456        // Numeric attribute
     *  }], ( error, assetDocs ) => {
     *      if ( error ) 
     *          return console.error( `Error: ${error}` )
     *
     *      console.log( `The asset ${assetDoc.identifier} was successfully created` ) 
     *      // => The asset asset-123 was successfully created
     *  })
     */

    // --------------------------------------------------------------------

    /**
     * Find an asset by its identifier - This isn't much different than the other asset searches, other than it just
     * specifies the where object for you. If were provided an array of identifiers, then return an object, with the
     * identifier value as the key, and only return the identifiers that were found to have assets - Meaning if an
     * identifier was provided and no asset was found for it, then don't return it.
     *
     * @function    module:AssetModel.findByIdentifier
     * @memberof    module:AssetModel
     * @this        module:AssetModel
     * @name        module:AssetModel.findByIdentifier
     * @throws      {module:AssetModel~AssetException}        This throws an AssetError exception
     * @param   {object}                options                 Object with the partition ID and identifier
     * @param   {function}              callback                Callback to execute, otherwise a promise is returned
     * @param   {string}                options.partitionId     Partition ID (Mongoose doc ObjectId)
     * @param   {string|number|array}   options.identifier      Primary field value to search for; A stringnumber will
     *                                                          search for one asset, an array of strings/number will
     *                                                          query for multiple
     * @returns {Promise}   Promise returned, or callback executed
     * @note    This is the same thing as Partition.findAssetByIdentifier(), except since this is a static method, the
     *          partitions ID needs to be specified
     * @todo    Should change this so the `options` parameter can accept the same thing as `options.identifier`
     * 
     * @example  // Find a single ...
     *  AssetModel.findByIdentifier({ 
     *      partitionId : 'd8i3nas0p3na1pvg98d763m',
     *      identifier  : 'webserver.phx.ad' 
     *  })
     *      .then( assetDoc => {
     *          console.log( `Asset found` )
     *          console.log( `\t Document ObjectId   : ${assetDoc._id.toString()}` )
     *          console.log( `\t Document Identifier : ${assetDoc.identifier}` )
     *      } )
     *      .catch( error => console.error( `Error: ${error}` ) )
     */
    AssetSchema.statics.findByIdentifier_old = function( options, callback ){
        return new Promise( ( res, rej ) => {
            if ( ! _.isObject( options ) ){
                return rej( new Error( 'No options specified, need to specify the partition ID and identifier' ) )
            }

            if ( ! _m.isObjectId( options.partitionId ) ){
                return rej( new Error( 'Invalid partition ID specified' ) )
            }

            if ( ! _.isString( options.identifier )
                &amp;&amp; ! _.isNumeric( options.identifier )
                &amp;&amp; ! _.isArray( options.identifier ) ){
                return rej( new Error( 'Invalid identifier provided, needs to be a string, number or array' ) )
            }

            const partitionId = options.partitionId
            const identifier  = options.identifier

            // Get the partition first, to get the ID of the primary field, then query for an asset using that
            Mongoose.models.Partition.getPartition( partitionId )
                .then( partitionData => {
                    const primaryField = _.find( partitionData._fields, f => !!f.primary )

                    if ( _.isEmpty( primaryField ) ){
                        return rej( new Error( 'No primary field found' ) )
                    }

                    const where = { 
                        'attributes._field': primaryField._id 
                    }

                    // If were looking for more than one asset, use an array as the where clause
                    if ( _.isArray( identifier ) ){
                        where[ 'attributes.value' ] = { 
                            $in: identifier 
                        }
                    }
                    // Or not
                    else {
                        where[ 'attributes.value' ] = identifier
                    }

                    // Query for an asset with the value as the primary fields ID, and the specified identifier
                    // Keep it as a sub-promise, because we need the primaryField data for the error
                    this.find( where )
                        .then( assetData => {
                            if ( _.isEmpty( assetData ) ){
                                return rej( new Error( `No asset found with the ${primaryField.name} '${(_.isArray( identifier ) ? identifier.join("', '") : identifier)}' in this partition` ) )
                            }

                            // If we were given an array, then structure an object, with the identifiers as the keys
                            if ( _.isArray( identifier ) ){
                                const result = {}

                                // Only add the assets that were found, so if there was an identifier provided that doesnt
                                // exist, then dont add it
                                _.forEach( assetData, ad => {
                                    let primaryAttr = _.find( ad.attributes, a => a._field._id.toString() === primaryField._id.toString() )

                                    result[ primaryAttr.value ] = ad
                                })

                                res( result )
                            }
                            // Otherwise, just return the only asset that should have been found
                            else {
                                res( assetData[ 0 ] )
                            }
                        })
                        .catch( err => rej( _.setException( err ) ) )
                })
                .catch( err => rej( _.setException( err ) ) )

        }).asCallback( callback )
    }

    AssetSchema.statics.findByIdentifier = function( partitionId, identifier, callback ){
        return new Promise( ( res, rej ) => {
            if ( ! _m.isObjectId( partitionId ) ){
                return rej( new Error( 'Invalid partition ID specified' ) )
            }

            if ( ! _.isString( identifier )
                &amp;&amp; ! _.isNumeric( identifier )
                &amp;&amp; ! _m.isObjectId( identifier )
                &amp;&amp; ! _.isArray( identifier ) ){
                return rej( new Error( 'Invalid identifier provided, needs to be a string, number or array' ) )
            }

            //const partitionId = options.partitionId
            //const identifier  = options.identifier

            // Get the partition first, to get the ID of the primary field, then query for an asset using that
            Mongoose.models.Partition.getPartition( partitionId )
                .then( partitionData => {
                    const primaryField = _.find( partitionData._fields, f => !!f.primary )

                    if ( _.isEmpty( primaryField ) ){
                        return rej( new Error( 'No primary field found' ) )
                    }

                    const where = { 
                        'attributes._field': primaryField._id 
                    }

                    // If were looking for more than one asset, use an array as the where clause
                    if ( _.isArray( identifier ) ){
                        where[ 'attributes.value' ] = { 
                            $in: identifier 
                        }
                    }
                    // Or not
                    else {
                        where[ 'attributes.value' ] = identifier
                    }

                    // Query for an asset with the value as the primary fields ID, and the specified identifier
                    // Keep it as a sub-promise, because we need the primaryField data for the error
                    this.find( where )
                        .then( assetData => {
                            if ( _.isEmpty( assetData ) ){
                                return rej( new Error( `No asset found with the ${primaryField.name} '${(_.isArray( identifier ) ? identifier.join("', '") : identifier)}' in this partition` ) )
                            }

                            // If we were given an array, then structure an object, with the identifiers as the keys
                            if ( _.isArray( identifier ) ){
                                return res( this.setIdentifiers( assetData ) )
                                /*
                                const result = {}

                                // Only add the assets that were found, so if there was an identifier provided that doesnt
                                // exist, then dont add it
                                _.forEach( assetData, ad => {
                                    let primaryAttr = _.find( ad.attributes, a => a._field._id.toString() === primaryField._id.toString() )

                                    result[ primaryAttr.value ] = ad
                                })

                                return res( result )
                                */
                            }

                            // Otherwise, just return the only asset that should have been found
                            return res( assetData )
                        })
                        .catch( err => rej( _.setException( err ) ) )
                })
                .catch( err => rej( _.setException( err ) ) )

        }).asCallback( callback )
    }

    // --------------------------------------------------------------------

    /**
     * Check if an attribute value exists for a specific field in a specific partition
     *
     * @function    module:AssetModel.isAttrValueUnique
     * @memberof    module:AssetModel
     * @this        module:AssetModel
     * @name        module:AssetModel.isAttrValueUnique
     * @throws      {module:AssetModel~AssetException}        This throws an AssetError exception
     * @param   {object}    data                Object with partition/field/value
     * @param   {function}  callback            Callback to fire (or a promise is returned)
     * @var     {string}    data.partitionId    Partition ID to query (can also be passed as data.partition)
     * @var     {Mixed}     data.value          Value to check (can also be passed as data.val)
     * @var     {string}    data.field          Field being validated (can also be passed as data.attr and
     *                                          data.attribute)
     * @returns {Promise}
     */
    AssetSchema.statics.isAttrValueUnique = function( data, callback ) {
        return new Promise( ( res, rej ) => {
            let partitionId = data.partitionId || data.partition
            let field       = data.field || data.attribute || data.attr
            let value       = ! _.isUndefined( data.value )
                ? data.value
                : data.val

            partitionId = partitionId.toString()
            field = field.toString()

            // Verify that a partition ID was specified (as partition or partitionId)
            //if ( ! _.isString( data.partitionId ) &amp;&amp; ! _.isString( data.partition ) )
            if ( ! _.isString( partitionId ) ){
                return rej( new Error( 'No partition ID specified' ) )
            }

            // Verify that a value was provided (as value or val)
            //if ( _.isUndefined( data.value ) &amp;&amp; _.isUndefined( data.val ) )
            if ( _.isUndefined( value ) ){
                return rej( new Error( 'No attribute value specified' ) )
            }

            // Verify that the field was specified (as field, attribute or attr)
            //if ( _.isUndefined( data.field ) &amp;&amp; _.isUndefined( data.attribute ) &amp;&amp; _.isUndefined( data.attr ) )
            if ( _.isUndefined( field ) ){
                return rej( new Error( 'No field was specified' ) )
            }

            // Start the where operator used in the query
            const where = { _partition: partitionId }

            // If were ignoring any asset IDs
            if ( ! _.isUndefined( data.ignore ) ){
                // Ignoring multiple asset IDs
                if ( _.isArray( data.ignore ) ){
                    if ( _.every( data.ignore, _m.isObjectId ) ){
                        where._id = { 
                            $nin: data.ignore 
                        }
                    }
                    else {
                        return rej( new Error( `Failed to validate unique value - one or more of the asset IDs provided in the ignore array was not a valid asset ID` ) )
                    }
                }

                // Ignoring a single asset ID
                else if ( _m.isObjectId( data.ignore ) ){
                    where._id = { 
                        $ne: data.ignore 
                    }
                }

                // The `data.ignore` value wasn't a valid ID or array of IDs
                return rej( new Error( `Failed to validate unique value - the asset ID provided is not a valid document ObjectId` ) )
            }

            this.find( where )
                //.populate( { path: '_partition' } )
                .populate( {
                    path: 'attributes._field' ,
                    match: { 
                        name: { 
                            $eq: field 
                        } 
                    }
                } )
                .then( data => {
                    // If any assets were found with this field, at all (not value specific yet)
                    if ( data.length > 0 ) {
                        // Check through those assets found for any matching values
                        return !! _.filter( data, d => !! _.filter( d.attributes, a => a.value == value ).length ).length
                            ? rej( new Error( `The value ${value} was found for another asset` ) )
                            : res( true )
                    }
                    
                    return res( true )
                })
                .catch( err => rej( _.setException( err ) ) )
        }).asCallback( callback )
    }

    // --------------------------------------------------------------------

    /**
     * Query for asset documents via the assets ObjectId (string for single, or array for multiple). *This method does
     * not require that all requested assets belong in the same partition*.
     *
     * @function    module:AssetModel.getAssets_old
     * @memberof    module:AssetModel
     * @this        module:AssetModel
     * @name        module:AssetModel.getAssets_old
     * @throws      {module:AssetModel~AssetException}        This throws an AssetError exception
     * @param   {(module:AssetModel~ObjectId|module:AssetModel~ObjectId[])} assetId   String specifying a specific asset 
     *                                                                                ID, or an array of multiple asset IDs
     * @param   {function}                                                  callback  Callback to execute, otherwise a 
     *                                                                                promise is returned
     * @note    The selectors are used as an 'AND' query, meaning: where partition = x AND asset = y
     * @todo    Add the ability to filter for assets, if a find static method isn't created
     * @return  {Promise}   With an array of Mongoose documents (assets), or callback executed
     * @ignore
     *
     * @example // Query a single Asset document via the assets ObjectId, using a **promise**
     * Asset.getAssets_old( '56d0819f655baf4a4a7f9cc9' )
     *     .then( data => console.log( 'Asset:', data ) )
     *     .catch( err => console.error( 'Error:', err ) )
     *
     * @example // Query a single Asset document via the assets ObjectId, using a callback
     * Asset.getAssets_old( '56d0819f655baf4a4a7f9cc9', ( err, data ) => {
     *     if ( err ) throw new Error( err )
     *
     *     console.log( 'Asset:', data )
     * })
     *
     * @example // Query multiple Asset documents via the asset ObjectIds, using a promise
     * Asset.getAssets_old( [
     *     '56d0819f655baf4a4a7f9cc9', 'd6da81hf6c5bef4a4a7c9ac1'
     * ] )
     *     .then( data => console.log( 'Assets:', data ) )
     *     .catch( err => console.error( 'Error:', err ) )
     *
     * @example // Query multiple Asset documents via the asset ObjectIds, using a callback
     * Asset.getAssets_old( [
     *     '56d0819f655baf4a4a7f9cc9', 'd6da81hf6c5bef4a4a7c9ac1'
     * ], ( err, data ) => {
     *     if ( err ) throw new Error( err )
     *
     *     console.log( 'Assets:', data )
     * })
     */
    AssetSchema.statics.getAssets_old = function( assetId, callback ) {
        return new Promise( ( res, rej ) => {
            // This where object will get populated, and used in the Mongoose find() query
            const where = {}

            // If a single asset Id was provided, add that to the where object
            if ( _m.isObjectId( assetId ) ) {
                where._id = assetId
            }

            // If one or more was specified, make sure they're all proper object IDs
            else if ( _.isArray( assetId ) ) {
                if ( ! _.every( assetId, a => _m.isObjectId( a ) ) ){
                    return rej( new Error( `One or more of the elements provided for the asset ID's array was not a proper ObjectId` ) )
                }
                else {
                    where._id = { $in: assetId }
                }
            }

            // Anything else should error out
            else {
                return rej( new Error( `Expecting an asset ID (ObjectId) or an array of asset ID's - Received: ${_.typeof( assetId )}` ) )
            }

            this.find( where )
                .then( assetData => {
                    if ( _.isEmpty( assetData ) ){
                        return rej( new Error( `No assets found for asset ID(s): ${_.isArray( assetId ) ? assetId.join( ', ' ) : assetId}` ) )
                    }

                    // Now populate ethe fields and resolve the assetDocs
                    this.populate( assetData._partition, { path: '_fields' }, ( err, result ) => res( assetData ) )
                } )
                .catch( err => rej( _.setException( err ) ) )
        } ).asCallback( ( _.isFunction( callback ) ? callback : null ) )
    }

    // --------------------------------------------------------------------

    /**
     * Retrieve all or one
     * 
     * @function    module:AssetModel.getPartitionsAssets
     * @memberof    module:AssetModel
     * @this        module:AssetModel
     * @name        module:AssetModel.getPartitionsAssets
     * @throws      {module:AssetModel~AssetException}          This throws an AssetError exception
     * @param       {(string|module:PartitionModel~ObjectId)}   partition       Partition name or partitions ObjectId
     * @param       {(object|function)=}                        attributesOrCb  Attributes to retrieve, or callback
     * @param       {function=}                                 callback        Callback to execute (if not treated as 
     *                                                                          promise)
     * 
     *
     * @example
     * AssetModel.getPartitionsAssets( 'Some Partition Name' )
     *     .then( assetDocs => console.log( 'Assets:', assetDocs ) )
     *     .catch( error => console.error( `Error retrieving assets - ${error.message}`))
     */
    AssetSchema.statics.getPartitionsAssets = function( partition, attributesOrCb, callback ) {
        return new Promise( ( res, rej ) => {
            if ( ! _m.isObjectId( partition ) ){
                return rej( new Error( `The partition needs to be a valid Partition ID` ) )
            }

            const where = { _partition: partition.toString() }

            if ( _.isObject( attributesOrCb ) ){
                _.assignIn( where, attributesOrCb )
            }

            this.find( where )
                .then( assetDocs => {
                    if ( _.isEmpty( assetDocs ) ){
                        return res( [] )
                    }

                    const result = []

                    // If theres some filters..
                    if ( _.isPlainObject( attributesOrCb ) &amp;&amp; ! _.isEmpty( attributesOrCb ) ){
                        // Values to pull out of the attributes object, as they aren't partition fields
                        let statics = [ 'status' ]

                        // Separate the static fields from the attributes object (Since they are stored differently in the DB)
                        statics = _.removeObj( attributesOrCb, statics )

                        // Statics are at the top level, so those are easy to search first, if any are set
                        if ( ! _.isEmpty( statics ) ){
                            let filteredStatics = _.remove( assetDocs, ad => {

                            })
                        }
                    }

                    res( assetDocs )
                } )
                .catch( err => rej( _.setException( err ) ))
        } ).asCallback( ( args  => _.findLast( args, a => _.isFunction( a ) ) )( arguments ) )
    }

    // --------------------------------------------------------------------

    /**
     * When assets are returned from a query, they are returned as an array of objects. This method can be used to 
     * restructure the array of objects into an object of objects, with the object keys being the value of the asset
     * identifiers (so could be an attribute value, or the ObjectId). The asset identifiers are populated by calling the
     * documents 'identifier' virtual property.
     *
     * @function    module:AssetModel.setIdentifiers
     * @memberof    module:AssetModel
     * @this        module:AssetModel
     * @name        module:AssetModel.setIdentifiers
     * @throws      {module:AssetModel~AssetException}          This throws an AssetError exception
     * @param   {array}     collection  Collection of assets (Array from a query)
     * @param   {boolean}   forceIds    If this is set to true, then the documents ObjectIds will be used as the object 
     *                                  keys (as opposed to using the primary attribute value, if available)
     * @returns {object}    The restructured object is returned
     * @note    This is setup as an instance method, so the partitions primary field ID can be grabbed without having
     *          to execute another query
     * @note    If the partition does NOT have a primary field, then the assets ID will be used as the identifier
     * @note    Any errors will throw a new Error()
     *
     * @example // Query for all assets in a partition, then reconstruct the result from an array of objects (asset 
     * // documents), to an object of objects, with the asset ID as the object keys
     * Asset.getPartitionsAssets( '56d0807d66b93cad49dbbbe4' )
     * .then( assets => {
     *     // Currently, assets is an array of objects
     *     return Asset.setIdentifiers( assets )
     * } )
     * .then( assets => {
     *     // After passing the assets array through Asset.setIdentifiers, 
     *     // assets is now an object of objects, with the asset 
     *     // identifiers as the object key values
     *     return console.log( '# RESULT:', assets )
     * } )
     * .catch( err => console.error( '# ERROR:',err ) )
     */
    AssetSchema.statics.setIdentifiers = function( collection, forceIds ){
        if ( ! _.isArray( collection ) ){
            throw new Error( `An array of asset documents is required - received a ${_.typeof(collection)}`)
        }

        return _.mapKeys( collection, a => a.identifier )
    }

    // --------------------------------------------------------------------

    /**
     * Retrieve a specific asset by the asset documents ObjectId. 
     *
     * @function    module:AssetModel.get
     * @alias       module:AssetModel.getAssets module:AssetModel.getAsset
     * @memberof    module:AssetModel
     * @this        module:AssetModel
     * @name        module:AssetModel.get
     * @throws      {module:AssetModel~AssetException}   This throws an AssetError exception
     * @param       {module:AssetModel~ObjectId}    assetId     Assets document Object Id or primary value (If parent 
     *                                                          partition has one)
     * @param       {module:AssetModel~getCb=}      callback    Callback to fire, or a promise is returned
     * @returns     {Promise}   Promise returned, or callback executed if provided
     * @todo        Allow this to work with the assets identifier
     *
     * @example // Query for a single Asset document
     * Asset.getAsset( '56d0819b655baf4a4a7f9cad' )
     *     .then( data => console.log( 'Result:', data ) )
     *     .catch( err => console.error( 'Error:', err ) )
     * 
     * @example // Query for multiple assets
     * Asset.getAssets( ['56d0819b655baf4a4a7f9cad','56d0819c655baf4a4a7f9cb4'] , ( err, data ) => {
     *     if ( err ) throw new Error( err )
     * 
     *     console.log( 'Result:', data )
     * })
     */
    AssetSchema.statics.get = 
    AssetSchema.statics.getAsset = 
    AssetSchema.statics.getAssets = function( assetId, callback ){
        let exc = Mongoose.exception()

        return new Promise( ( res, rej ) => {
            //console.log('Finding ID:',assetId)
            let docQuery

            // If more than one asset ID was provided in an array.. then return an array of results
            if ( _.isArray( assetId ) ){
                docQuery = this.find({
                    _id: { $in: assetId }
                })
            }

            // Otherwise, return a single object
            else if ( _.isString( assetId ) || _m.isObjectId( assetId ) ) {
                docQuery = this.findById( assetId )
            }

            // 
            else {
                return rej( new ModelException( 'Invalid asset ID specified' )) 
            }

            docQuery
                .then( assetDoc => {
                    // If no results were found, then 
                    if ( _.isEmpty( assetDoc ) ){
                        var idTxt = ( _.isArray( assetId ) ? 'IDs ' + assetId.join(', ') : 'ID ' + assetId )

                        return rej( new ModelException( `Asset ${idTxt} not found` ) )
                    }

                    // If more than one asset ID was provided in an array.. then return the Document Objects in an 
                    // object, with the document identifiers as the object keys
                    if ( _.isArray( assetId ) ){
                        return res( this.setIdentifiers( assetDoc ) )
                    }

                    // Otherwise, return a single object
                    return res( assetDoc )
                })
                .catch( err => {
                    console.error('Error:',err)
                    return rej( _.setException( err ) )
                } )
        }).asCallback( callback )
    }

    /**
     * Callback executed when a single asset document is queried via the static AssetSchema.get method. The 'data'
     * parameter can be either an object (for a single asset), or an array (for multiple). This depends solely on asset
     * ID or IDs was provided - If an array of asset ID's was provided, then this will be an array of asset documents 
     * (even if only one of the asset ID's was found).
     *
     * @function
     * @type function
     * @name getCb
     * @callback module:AssetModel~getCb
     * @param {?(string|Exception)}         error       Error that was thrown, or null for no error
     * @param {?Object}                     data        MongoDb document of Asset found, or null if none found
     * @param {module:AssetModel~ObjectId}  data._id    Asset ID
     *
     * @example // Create a single asset without any attribute values defined
     *  AssetModel.get( 'd8i3nas0p3na1pvg98d763m', ( error, data ) =>{
     *      if ( error )
     *          return console.error( 'Error:', error )
     *      
     *      console.log( 'Asset Returned:', data.identifier )
     *      // => Asset Returned: d8i3nas0p3na1pvg98d763m
     *  } )
     */

    // --------------------------------------------------------------------

    /**
     * Find multiple assets, given specific criteria
     *
     * @function    module:AssetModel.findAssets
     * @memberof    module:AssetModel
     * @this        module:AssetModel
     * @name        module:AssetModel.findAssets
     * @throws      {module:AssetModel~AssetException}   This throws an AssetError exception
     * @param       {(Object|string)}               criteria    Search criteria
     * @param       {module:AssetModel~findAssetsCb=}     callback    Callback to fire, or a promise is returned
     * @returns     {Promise}   Promise returned, or callback executed if provided
     */
    AssetSchema.statics.findAssets = function( criteria, callback ){
        return new Promise( ( res, rej ) => {
         
        }).asCallback( callback )
    }

    /**
     * Callback executed when one or more asset documents are returned from the static AssetSchema.find method
     *
     * @function
     * @type function
     * @name findAssetsCb
     * @callback module:AssetModel~findAssetsCb
     * @param {?(string|Exception)}         error       Error that was thrown, or null for no error
     * @param {?Object}                     data        MongoDb document of Asset found, or null if none found
     * @param {module:AssetModel~ObjectId}  data._id    Asset ID
     *
     * @example // Find all unlocked assets in the partition with the ID a8icnasdp3ng1pve98dg63c
     *  AssetModel.findAssets( { 
     *      _partition: 'a8icnasdp3ng1pve98dg63c',
     *       status: 'unlocked' 
     *  }, ( error, assetDocs ) =>{
     *      if ( error )
     *          return console.error( 'Error:', error )
     *      
     *      console.log( 'Number of Asset Returned:', _.size( assetDocs ) )
     *      // => Number of Asset Returned: 12
     *  } )
     */

    // --------------------------------------------------------------------

    /**
     * Find a single asset, this is essentially the same as the static [find]{@link module:AssetModel.find} method, 
     * except only the first result is returned.
     *
     * @function    module:AssetModel.findAsset
     * @memberof    module:AssetModel
     * @this        module:AssetModel
     * @name        module:AssetModel.findAsset
     * @throws      {module:AssetModel~AssetException}   This throws an AssetError exception
     * @param       {(Object|string)}               criteria    Search criteria
     * @param       {module:AssetModel~findAssetCb=}     callback    Callback to fire, or a promise is returned
     * @returns     {Promise}   Promise returned, or callback executed if provided
     */
    AssetSchema.statics.findAsset = function( criteria, callback ){
        return new Promise( ( res, rej ) => {
         
        }).asCallback( callback )
    }

    /**
     * Callback executed when a single asset document is queried via the static [findAsset]{@link module:AssetModel.findAsset} 
     * method
     *
     * @function
     * @type function
     * @name findAssetCb
     * @callback module:AssetModel~findAssetCb
     * @param {?(string|Exception)}         error       Error that was thrown, or null for no error
     * @param {?Object}                     data        MongoDb document of Asset found, or null if none found
     * @param {module:AssetModel~ObjectId}  data._id    Asset ID
     *
     * @example // Create a single asset without any attribute values defined
     *  AssetModel.findAsset( 'd8i3nas0p3na1pvg98d763m', ( error, assetDoc ) =>{
     *      if ( error )
     *          return console.error( 'Error:', error )
     *      
     *      console.log( 'Asset Returned:', assetDoc.identifier )
     *      // => Asset Returned: d8i3nas0p3na1pvg98d763m
     *  } )
     */

    // --------------------------------------------------------------------

    /**
     * Delete one or more assets by the Asset ObjectIds, unlike the Partition models delete method, this doesn't
     * require a Partition object
     *
     * @function    module:AssetModel.delete
     * @alias       module:AssetModel.deleteAsset, module:AssetModel.deleteAssets
     * @memberof    module:AssetModel
     * @this        module:AssetModel
     * @name        module:AssetModel.delete
     * @throws      {module:AssetModel~AssetException}   This throws an AssetError exception
     *
     * @param   {(string|object|array|module:AssetModel~ObjectId)}  options           Options with asset ObjectIds and other 
     *                                                                                options;  A string for a single asset 
     *                                                                                ObjectId; Or an array of ObjectIds for 
     *                                                                                multiple assets
     * @param   {string=}                                           options.comment   Remark on why the asset(s) were deleted
     * @param   {module:AssetModel~deleteStaticCb=}                 callback          Callback to execute (optional)
     * @return  {Promise}   On success, an array of asset data is returned, if requireDelete is false,
     *                      and no assets were found/deleted, then null is returned
     * @todo  Determine what data is handed to the promise (last asset document data? asset ID? nothing?)
     *
     * @example // Delete a single asset (handled as a promise) via the asset ID
     *  AssetModel.delete( '56d0819b655baf4a4a7f9cad' )
     *      .then( data => {
     *          console.log( `Deleted ....??` )
     *          // => Deleted
     *      })
     *      .catch( error => console.error( `Error: ${error}` ) )
     *
     * @example // Delete two assets (handled as a promise) via one asset ID and one asset primary value
     *  AssetModel.delete( [
     *      '56d0819b655baf4a4a7f9cad', 'asset-123'
     *  ] )
     *      .then( data => {
     *          console.log( `Deleted ....??` )
     *          // => Deleted
     *      })
     *      .catch( error => console.error( `Error: ${error}` ) )
     * 
     * @example // Same as previous example, except the options parameter is an object, and a comment is specified
     *  AssetModel.delete( {
     *      assetIds : [ '56d0819b655baf4a4a7f9cad', 'asset-123' ],
     *      comment  : 'Deleting a few assets, because I feel like it'
     *  })
     *      .then( data => {
     *          console.log( `Deleted ....??` )
     *          // => Deleted
     *      })
     *      .catch( error => console.error( 'Error:', error )
     */
    AssetSchema.statics.delete = 
    AssetSchema.statics.deleteAsset = 
    AssetSchema.statics.deleteAssets = function( options, callback ){
        return new Promise( ( res, rej ) => {
            let assetIds
            let requireDelete = false

            //assetIds, requireDelete = false
            // An object will have more than just the asset Ids (possibly)..
            if ( _.isObject( options ) ){
                // If assetIds isnt present throw an error
                if ( _.isUndefined( options.assetIds ) ){
                    throw new Error( 'No asset IDs specified to delete' )
                }
                // Yay, asset ID's were specified
                else {
                    assetIds = options.assetIds
                }

                // See if requireDelete was set
                requireDelete = _.isBoolean( options.requireDelete )
                    ? options.requireDelete
                    : false
            }
            // An array or string is one or more asset IDs
            else if ( _.isArray( options ) || _.isString( options ) ){
                assetIds = options
            }
            // If it gets here, then no asset ID(s) were specified
            else {
                throw new Error( 'No asset ID(s) specified to delete' )
            }

            // Add the successfully deleted asset data to results.deleted, and the failed ID's to results.failed
            let results = { deleted: [], error: [] }

            /* @todo Switch the below Async.each to this
            Async.mapSeries( assets, ( thisAsset, asyncCb ) => {
                this.deleteAsset( { asset: thisAsset, requireDelete: requireDelete }, ( error, result ) => asyncCb( error, result ))
            }, ( error, results ) =>  error
                ? rej( error )
                : res( results ) )
            */

            // Delete all assets asynchronously, saving the data to the results object
            Async.each( _.flattenDeep( [ assetIds ] ), ( assetId, done ) => {
                this.findByIdAndRemove( assetId )
                    .then( data => {
                        // If data is falsey, then it didn't delete, add the ID to the error array
                        if ( ! data ){
                            results.error.push( assetId )
                        }
                        // Otherwise, add the asset data to the deleted data array
                        else {
                            results.deleted.push( data )
                        }

                        done()
                    } )
                    .catch( err => rej( _.setException( err ) ) )
            }, err => {
                if ( err ){
                    return rej( _.setException( err ) )
                }

                // Remove either array that may be empty
                results = _.omitBy( results, _.isEmpty )

                // If requireDelete is true, and there were some errors, then reject (but with same data as a success)
                if ( results.error &amp;&amp; requireDelete ){
                    rej( _.setException( results ) )
                }
                
                res( results )
            })
        }).asCallback( callback )
    }

    /**
     * Callback executed when static method module:AssetModel.delete is executed and provided a callback
     *
     * @function
     * @type function
     * @name deleteStaticCb
     * @callback module:AssetModel~deleteStaticCb
     * @param {?(string|Exception)} error               Error that was thrown, or null for no error
     * @param {Object}              data                MDB document of the newly created Asset
     * @todo  Determine what data is handed to the data parameter
     *
     * @example // Delete one asset, using the assets ObjectId
     *  AssetModel.delete( '56d0819b655baf4a4a7f9cad', ( error, data ) => {
     *      if ( error ) 
     *          return console.error( `Error: ${error}` )
     *
     *      console.log( `Deleted ....??` )
     *      // => Deleted
     *  } )
     * 
     * @example // Delete two assets (handled as a callback) via the primary value for one, and ObjectId for the other asset
     *  AssetModel.delete( [
     *      '56d0819b655baf4a4a7f9cad', 'asset-123'
     *  ], ( error, data ) => {
     *      if ( error ) 
     *          return console.error( `Error: ${error}` )
     *
     *      console.log( `Deleted ....??` )
     *      // => Deleted
     *  } )
     * 
     * @example // Same as previous example, except the options parameter is an object, and a comment is specified
     *  AssetModel.delete( {
     *      assetIds : [ '56d0819b655baf4a4a7f9cad', 'asset-123' ],
     *      comment  : 'Deleting a few assets, because I feel like it'
     *  }, ( error, data ) => {
     *      if ( error ) 
     *          return console.error( `Error: ${error}` )
     *
     *      console.log( `Deleted ....??` )
     *      // => Deleted
     *  } )
     */

    // --------------------------------------------------------------------

    Log.debug('Returning compiled model schema')

    return Mongoose.model( ModelName, AssetSchema )
}</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Jun 27 2017 11:28:14 GMT-0700 (MST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
